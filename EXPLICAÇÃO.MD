# Stock Net - Implementa√ß√£o de Padr√µes de Projeto

Este projeto demonstra a aplica√ß√£o de tr√™s padr√µes de projeto no contexto de um sistema de gerenciamento de estoque:

- **N-Camadas** (Padr√£o Arquitetural)
- **Factory Method** (Padr√£o Criacional)
- **Observer** (Padr√£o Comportamental)

Cada padr√£o foi implementado separadamente para exemplificar sua utiliza√ß√£o.

---

## 1. N-Camadas (Padr√£o Arquitetural)

### **Explica√ß√£o**

A arquitetura **N-Camadas** divide a aplica√ß√£o em m√∫ltiplas camadas l√≥gicas, garantindo separa√ß√£o de responsabilidades. As camadas t√≠picas incluem:

- **Camada de Apresenta√ß√£o** (Front-end) - Interface com o usu√°rio.
- **Camada de Neg√≥cios** (Back-end) - Processamento das regras de neg√≥cio.
- **Camada de Dados** (Banco de Dados) - Armazena e gerencia os dados.

Essa arquitetura melhora a escalabilidade, manutenibilidade e modularidade do sistema.

### **Como foi aplicado**

No **Stock Net**, utilizamos a arquitetura **N-Camadas** separando as responsabilidades em:

- **Controllers**: Gerenciam as requisi√ß√µes HTTP.
- **Services**: Cont√™m a l√≥gica de neg√≥cios.
- **Repositories**: Lidam com o banco de dados.

#### **Exemplo de Implementa√ß√£o**

```typescript
// materials.controller.ts
import { Controller, Get, Post, Body } from '@nestjs/common';
import { MaterialsService } from './materials.service';
import { CreateMaterialDto } from './dto/create-material.dto';

@Controller('materials')
export class MaterialsController {
  constructor(private readonly materialsService: MaterialsService) {}

  @Post()
  create(@Body() createMaterialDto: CreateMaterialDto) {
    return this.materialsService.create(createMaterialDto);
  }

  @Get()
  findAll() {
    return this.materialsService.findAll();
  }
}
```

```typescript
// materials.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Material } from './entities/material.entity';

@Injectable()
export class MaterialsService {
  constructor(
    @InjectRepository(Material)
    private materialRepository: Repository<Material>,
  ) {}

  async create(material: Material): Promise<Material> {
    return this.materialRepository.save(material);
  }

  async findAll(): Promise<Material[]> {
    return this.materialRepository.find();
  }
}
```

### **Benef√≠cios da Arquitetura N-Camadas**

‚úÖ Melhor organiza√ß√£o do c√≥digo. ‚úÖ Maior facilidade na manuten√ß√£o e escalabilidade. ‚úÖ Permite substitui√ß√£o ou atualiza√ß√£o de camadas individuais sem afetar o restante do sistema.

---

## 2. Factory Method (Padr√£o Criacional)

### **Explica√ß√£o**

O **Factory Method** √© um padr√£o criacional que define uma interface para criar objetos, mas permite que as subclasses alterem o tipo de objetos que ser√£o criados. Ele melhora a manuten√ß√£o do c√≥digo ao centralizar a l√≥gica de cria√ß√£o de objetos.

### **Como foi aplicado**

No contexto do sistema **Stock Net**, criamos uma **f√°brica de materiais** para centralizar a l√≥gica de cria√ß√£o de objetos `Material`.

#### **Implementa√ß√£o**

```typescript
// material.factory.ts
import { Material } from './material.entity';

export abstract class MaterialFactory {
  abstract criarMaterial(
    descricao: string,
    quantidade: number,
    unidadeMedida: string
  ): Material;
}

export class MaterialConcretoFactory extends MaterialFactory {
  criarMaterial(
    descricao: string,
    quantidade: number,
    unidadeMedida: string
  ): Material {
    return new Material(descricao, quantidade, unidadeMedida);
  }
}
```

#### **Uso da Factory**

```typescript
// main.ts
import { MaterialConcretoFactory } from './material.factory';

const factory = new MaterialConcretoFactory();
const caboRede = factory.criarMaterial('Cabo de Rede', 100, 'metros');
console.log(caboRede);
```

### **Benef√≠cios do Factory Method**

‚úÖ Centraliza a cria√ß√£o de objetos em um s√≥ lugar.\
‚úÖ Facilita a manuten√ß√£o e expans√£o do sistema.\
‚úÖ Permite a cria√ß√£o de diferentes tipos de materiais sem modificar a l√≥gica existente.

---

## 3. Observer (Padr√£o Comportamental)

### **Explica√ß√£o**

O **Observer** √© um padr√£o comportamental que define uma depend√™ncia **1-para-muitos** entre objetos. Quando um objeto muda de estado, todos os seus observadores s√£o notificados automaticamente.

### **Como foi aplicado**

No sistema **Stock Net**, usamos o **Observer** para notificar automaticamente os usu√°rios quando houver uma movimenta√ß√£o de estoque.

#### **Implementa√ß√£o**

```typescript
// notificacao.service.ts
export class NotificacaoService {
  private observers: ((message: string) => void)[] = [];

  adicionarObserver(observer: (message: string) => void) {
    this.observers.push(observer);
  }

  notificar(message: string) {
    this.observers.forEach((observer) => observer(message));
  }
}
```

#### **Uso do Observer**

```typescript
// main.ts
import { NotificacaoService } from './notificacao.service';
import { MovimentacaoEstoqueService } from './movimentacao.service';

const notificacaoService = new NotificacaoService();
const movimentacaoService = new MovimentacaoEstoqueService(notificacaoService);

notificacaoService.adicionarObserver((mensagem) => {
  console.log(`üì¢ Usu√°rio recebeu notifica√ß√£o: ${mensagem}`);
});

notificacaoService.adicionarObserver((mensagem) => {
  console.log(`üì¢ Administrador recebeu notifica√ß√£o: ${mensagem}`);
});

movimentacaoService.registrarMovimentacao('Cabo de Rede', 'sa√≠da', 10);
```

### **Benef√≠cios do Observer**

‚úÖ Desacopla a l√≥gica de notifica√ß√µes do servi√ßo de movimenta√ß√£o.\
‚úÖ Permite adicionar novos observadores sem modificar o c√≥digo existente.\
‚úÖ Melhora a escalabilidade do sistema.

---

## üìå Conclus√£o

Neste projeto, implementamos tr√™s padr√µes de projeto:

1. **N-Camadas**, para estruturar a aplica√ß√£o de forma modular e escal√°vel.
2. **Factory Method**, para centralizar e padronizar a cria√ß√£o de materiais.
3. **Observer**, para notificar automaticamente os usu√°rios sobre movimenta√ß√µes no estoque.

Todos os padr√µes ajudam a tornar o sistema mais organizado, flex√≠vel e f√°cil de manter. üöÄ

